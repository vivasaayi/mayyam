use std::{sync::Arc, fs};
use tracing::{info, debug};
use serde::{Deserialize, Serialize};
use serde_json::json;
use chrono::{DateTime, Utc};

use aws_types;
use aws_config;
use aws_sdk_ec2::Client as Ec2Client;
use aws_sdk_s3::Client as S3Client;
use aws_sdk_rds::Client as RdsClient;
use aws_sdk_dynamodb::Client as DynamoDbClient;
use aws_sdk_kinesis::Client as KinesisClient;
use aws_sdk_sqs::Client as SqsClient;
use aws_sdk_sns::Client as SnsClient;
use aws_sdk_lambda::Client as LambdaClient;
use aws_sdk_elasticache::Client as ElasticacheClient;
use aws_sdk_opensearch::Client as OpenSearchClient;
use aws_sdk_costexplorer::Client as CostExplorerClient;
use aws_sdk_cloudwatch::Client as CloudWatchClient;
use aws_sdk_cloudwatch::types::{MetricDataQuery, Dimension, Metric, MetricStat};
use aws_sdk_costexplorer::types::{Granularity, Expression, DimensionValues};
use aws_sdk_costexplorer::operation::get_cost_and_usage::GetCostAndUsageInput;

use crate::config::{Config, AwsConfig};
use crate::repositories::aws_resource::AwsResourceRepository;
use crate::models::aws_resource::{AwsResourceDto, Model as AwsResourceModel, AwsResourceType};
use crate::errors::AppError;
use crate::models::aws_auth::AccountAuthInfo;
use crate::services::aws_client_factory::AwsClientFactory;
use async_trait::async_trait;

// Separate control plane and data plane operations
pub struct AwsService {
    aws_resource_repo: Arc<AwsResourceRepository>,
    config: Config,
}

// Control plane operations for AWS resources
pub struct AwsControlPlane {
    aws_service: Arc<AwsService>,
}

// Data plane operations for AWS resources
pub struct AwsDataPlane {
    aws_service: Arc<AwsService>,
}

// Specialized services for cost analysis and monitoring
pub struct AwsCostService {
    aws_service: Arc<AwsService>,
    cost_explorer_client: CostExplorerClient,
}

impl AwsCostService {
    pub fn new(aws_service: Arc<AwsService>) -> Self {
        // Initialize with a default US East 1 region for Cost Explorer
        let shared_config = aws_config::from_env().region("us-east-1").load().sync();
        let cost_explorer_client = CostExplorerClient::new(&shared_config);
        
        AwsCostService {
            aws_service,
            cost_explorer_client,
        }
    }

    pub async fn get_cost_and_usage(
        &self,
        account_id: &str,
        profile: Option<&str>,
        region: &str,
        start_date: &str,
        end_date: &str,
    ) -> Result<serde_json::Value, AppError> {
        // Create a client for the specified region
        let client = self.aws_service.create_cost_explorer_client(profile, region).await?;

        // Create time period for the request
        let time_period = aws_sdk_costexplorer::types::DateInterval::builder()
            .start(start_date)
            .end(end_date)
            .build()
            .map_err(|e| AppError::External(format!("Failed to build time period: {}", e)))?;

        // Build dimension values for resource filtering
        let dimension_values = aws_sdk_costexplorer::types::DimensionValues::builder()
            .key(aws_sdk_costexplorer::types::Dimension::LinkedAccount)
            .values(vec![account_id.to_string()])
            .build()
            .map_err(|e| AppError::External(format!("Failed to build dimension values: {}", e)))?;

        // Build the filter expression
        let filter = aws_sdk_costexplorer::types::Expression::builder()
            .dimensions(dimension_values)
            .build()
            .map_err(|e| AppError::External(format!("Failed to build filter: {}", e)))?;

        // Build and execute the request
        let result = client
            .get_cost_and_usage()
            .set_time_period(Some(time_period))
            .granularity(aws_sdk_costexplorer::types::Granularity::Daily)
            .filter(filter)
            .metrics(vec!["UnblendedCost".to_string()])
            .send()
            .await
            .map_err(|e| AppError::CloudProvider(e.to_string()))?;

        // Convert the results into a format suitable for the API response
        let response = json!({
            "start_date": start_date,
            "end_date": end_date,
            "granularity": "DAILY",
            "results": result.results_by_time().unwrap_or_default().iter().map(|time_period| {
                json!({
                    "timestamp": time_period.time_period().map(|tp| tp.start()).unwrap_or_default(),
                    "cost": time_period.total().and_then(|t| t.get("UnblendedCost"))
                        .and_then(|c| c.amount())
                        .and_then(|a| a.parse::<f64>().ok())
                        .unwrap_or(0.0),
                    "unit": time_period.total().and_then(|t| t.get("UnblendedCost"))
                        .and_then(|c| c.unit())
                        .map(|u| u.as_str())
                        .unwrap_or("USD")
                })
            }).collect::<Vec<_>>()
        });

        Ok(response)
    }
}

pub struct CloudWatchService {
    aws_service: Arc<AwsService>,
    cloudwatch_client: CloudWatchClient,
}

impl CloudWatchService {
    pub fn new(aws_service: Arc<AwsService>) -> Self {
        // Initialize with a default US East 1 region for CloudWatch
        let shared_config = aws_config::from_env().region("us-east-1").load().sync();
        let cloudwatch_client = CloudWatchClient::new(&shared_config);
        
        CloudWatchService {
            aws_service,
            cloudwatch_client,
        }
    }

    pub async fn get_logs(
        &self,
        profile: Option<&str>,
        region: &str,
        request: &CloudWatchLogsRequest,
    ) -> Result<serde_json::Value, AppError> {
        let client = self.aws_service.create_cloudwatch_client(profile, region).await?;
        
        info!("Getting CloudWatch logs for log group {}", request.log_group_name);

        let list_log_streams = client
            .describe_log_streams()
            .log_group_name(&request.log_group_name)
            .descending(true)
            .limit(1)
            .send()
            .await
            .map_err(|e| AppError::CloudProvider(format!("Failed to get log streams: {}", e)))?;

        let mut response = Vec::new();
        if let Some(streams) = list_log_streams.log_streams() {
            for stream in streams {
                if let Some(stream_name) = stream.log_stream_name() {
                    let logs = client
                        .get_log_events()
                        .log_group_name(&request.log_group_name)
                        .log_stream_name(stream_name)
                        .start_time(request.start_time.timestamp_millis())
                        .end_time(request.end_time.timestamp_millis())
                        .start_from_head(true)
                        .send()
                        .await
                        .map_err(|e| AppError::CloudProvider(format!("Failed to get log events: {}", e)))?;

                    if let Some(events) = logs.events() {
                        for event in events {
                            if let Some(message) = event.message() {
                                // Apply filter pattern if specified
                                if let Some(pattern) = &request.filter_pattern {
                                    if !message.contains(pattern) {
                                        continue;
                                    }
                                }
                                response.push(json!({
                                    "timestamp": event.timestamp(),
                                    "message": message,
                                }));
                            }
                        }
                    }
                }
            }
        }

        Ok(json!({
            "log_group": request.log_group_name,
            "events": response
        }))
    }

    pub async fn schedule_metrics_collection(
        &self,
        request: &MetricsCollectionRequest,
        interval_seconds: i64,
    ) -> Result<serde_json::Value, AppError> {
        // For now, we'll just verify the request parameters and return a success response
        // In a real implementation, you would set up a scheduled task to collect metrics
        
        info!("Scheduling metrics collection for resource {}", request.resource_id);

        // Validate the request
        if request.metrics.is_empty() {
            return Err(AppError::BadRequest("No metrics specified".to_string()));
        }

        if interval_seconds < 60 {
            return Err(AppError::BadRequest("Interval must be at least 60 seconds".to_string()));
        }

        let client = self.aws_service.create_cloudwatch_client(None, &request.region).await?;
        
        // Verify the resource exists by attempting to get a single metric
        let metric = MetricDataQuery::builder()
            .metric_stat(
                MetricStat::builder()
                    .metric(
                        Metric::builder()
                            .namespace(match request.resource_type.as_str() {
                                "EC2Instance" => "AWS/EC2",
                                "RdsInstance" => "AWS/RDS",
                                "DynamoDbTable" => "AWS/DynamoDB",
                                "ElasticacheCluster" => "AWS/ElastiCache",
                                _ => return Err(AppError::BadRequest(format!("Unsupported resource type: {}", request.resource_type))),
                            })
                            .metric_name(&request.metrics[0])
                            .dimensions(vec![
                                Dimension::builder()
                                    .name(match request.resource_type.as_str() {
                                        "EC2Instance" => "InstanceId",
                                        "RdsInstance" => "DBInstanceIdentifier",
                                        "DynamoDbTable" => "TableName",
                                        "ElasticacheCluster" => "CacheClusterId",
                                        _ => return Err(AppError::BadRequest("Invalid resource type".to_string())),
                                    })
                                    .value(&request.resource_id)
                                    .build()
                                    .map_err(|e| AppError::CloudProvider(e.to_string()))?
                            ])
                            .build()
                            .map_err(|e| AppError::CloudProvider(e.to_string()))?
                    )
                    .period(request.period)
                    .stat("Average")
                    .build()
                    .map_err(|e| AppError::CloudProvider(e.to_string()))?
            )
            .id("test")
            .build()
            .map_err(|e| AppError::CloudProvider(e.to_string()))?;

        let now = Utc::now();
        let response = json!({
            "status": "scheduled",
            "resource_id": request.resource_id,
            "resource_type": request.resource_type,
            "metrics": request.metrics,
            "interval_seconds": interval_seconds,
            "region": request.region,
            "period": request.period,
            "start_time": now.to_rfc3339(),
            "next_collection": now + chrono::Duration::seconds(interval_seconds),
        });

        Ok(response)
    }

    pub async fn get_metrics(&self, profile: Option<&str>, region: &str, request: &CloudWatchMetricsRequest) -> Result<CloudWatchMetricsResult, AppError> {
        // Get a CloudWatch client for the specified region
        let client = self.aws_service.create_cloudwatch_client(profile, region).await?;

        let namespace = match request.resource_type.as_str() {
            "EC2Instance" => "AWS/EC2",
            "RdsInstance" => "AWS/RDS", 
            "DynamoDbTable" => "AWS/DynamoDB",
            "ElasticacheCluster" => "AWS/ElastiCache",
            _ => return Err(AppError::BadRequest(format!("Unsupported resource type: {}", request.resource_type))),
        };

        let mut metrics_data = Vec::new();
        for metric_name in &request.metrics {
            // Create dimensions based on resource type
            let dimensions = match request.resource_type.as_str() {
                "EC2Instance" => vec![
                    Dimension::builder()
                        .name("InstanceId")
                        .value(&request.resource_id)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                ],
                "RdsInstance" => vec![
                    Dimension::builder()
                        .name("DBInstanceIdentifier")
                        .value(&request.resource_id)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                ],
                "DynamoDbTable" => vec![
                    Dimension::builder()
                        .name("TableName")
                        .value(&request.resource_id)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                ],
                "ElasticacheCluster" => vec![
                    Dimension::builder()
                        .name("CacheClusterId")
                        .value(&request.resource_id)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                ],
                _ => vec![],
            };

            let metric_stat = MetricStat::builder()
                .metric(
                    Metric::builder()
                        .namespace(namespace)
                        .metric_name(metric_name)
                        .dimensions(dimensions)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                )
                .period(request.period)
                .stat("Average")
                .build()
                .map_err(|e| AppError::External(e.to_string()))?;

            let metric_query = MetricDataQuery::builder()
                .metric_stat(metric_stat)
                .id(format!("m{}", metrics_data.len()))
                .build()
                .map_err(|e| AppError::External(e.to_string()))?;

            let get_metric_data_input = aws_sdk_cloudwatch::operation::get_metric_data::GetMetricDataInput::builder()
                .start_time(request.start_time)
                .end_time(request.end_time)
                .metric_data_queries(vec![metric_query])
                .build()
                .map_err(|e| AppError::External(e.to_string()))?;

            let metric_result = client.get_metric_data(get_metric_data_input).await
                .map_err(|e| AppError::External(e.to_string()))?;

            let mut datapoints = Vec::new();
            if let Some(results) = metric_result.metric_data_results() {
                for result in results {
                    if let (Some(timestamps), Some(values)) = (result.timestamps(), result.values()) {
                        for (ts, val) in timestamps.iter().zip(values.iter()) {
                            datapoints.push(CloudWatchDatapoint {
                                timestamp: *ts,
                                value: *val,
                                unit: "Count".to_string(), // Default unit, should be made dynamic
                            });
                        }
                    }
                }
            }

            metrics_data.push(CloudWatchMetricData {
                namespace: namespace.to_string(),
                metric_name: metric_name.clone(),
                unit: "Count".to_string(), // Default unit, should be made dynamic
                datapoints,
            });
        }

        Ok(CloudWatchMetricsResult {
            resource_id: request.resource_id.clone(),
            resource_type: request.resource_type.clone(),
            metrics: metrics_data,
        })
    }

    pub async fn get_logs(
        &self,
        profile: Option<&str>,
        region: &str,
        request: &CloudWatchLogsRequest,
    ) -> Result<serde_json::Value, AppError> {
        let client = self.aws_service.create_cloudwatch_client(profile, region).await?;
        
        info!("Getting CloudWatch logs for log group {}", request.log_group_name);

        let list_log_streams = client
            .describe_log_streams()
            .log_group_name(&request.log_group_name)
            .descending(true)
            .limit(1)
            .send()
            .await
            .map_err(|e| AppError::CloudProvider(format!("Failed to get log streams: {}", e)))?;

        let mut response = Vec::new();
        if let Some(streams) = list_log_streams.log_streams() {
            for stream in streams {
                if let Some(stream_name) = stream.log_stream_name() {
                    let logs = client
                        .get_log_events()
                        .log_group_name(&request.log_group_name)
                        .log_stream_name(stream_name)
                        .start_from_head(true)
                        .send()
                        .await
                        .map_err(|e| AppError::CloudProvider(format!("Failed to get log events: {}", e)))?;

                    if let Some(events) = logs.events() {
                        for event in events {
                            response.push(json!({
                                "timestamp": event.timestamp(),
                                "message": event.message().unwrap_or_default(),
                            }));
                        }
                    }
                }
            }
        }

        Ok(json!({
            "log_group": request.log_group_name,
            "events": response
        }))
    }

    pub async fn schedule_metrics_collection(
        &self,
        request: &MetricsCollectionRequest,
        interval_seconds: i64,
    ) -> Result<serde_json::Value, AppError> {
        // For now, we'll just verify the request parameters and return a success response
        // In a real implementation, you would set up a scheduled task to collect metrics
        
        info!("Scheduling metrics collection for resource {}", request.resource_id);
        
        let response = json!({
            "status": "scheduled",
            "resource_id": request.resource_id,
            "metrics": request.metrics,
            "interval_seconds": interval_seconds,
            "start_time": chrono::Utc::now().to_rfc3339(),
        });

        Ok(response)
    }
}

// Common Request/Response types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceSyncRequest {
    pub account_id: String,
    pub profile: Option<String>,
    pub region: String,
    pub resource_types: Option<Vec<String>>,
    // Authentication fields
    pub use_role: bool,
    pub role_arn: Option<String>,
    pub external_id: Option<String>,
    pub access_key_id: Option<String>,
    pub secret_access_key: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceSyncResponse {
    pub summary: Vec<ResourceTypeSyncSummary>,
    pub total_resources: usize,
    pub sync_time: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceTypeSyncSummary {
    pub resource_type: String,
    pub count: usize,
    pub status: String,
    pub details: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct S3PutObjectRequest {
    pub bucket: String,
    pub key: String,
    pub content_type: Option<String>,
    pub body: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct S3GetObjectRequest {
    pub bucket: String,
    pub key: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SqsSendMessageRequest {
    pub queue_url: String,
    pub message_body: String,
    pub delay_seconds: Option<i32>,
    pub message_attributes: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SqsReceiveMessageRequest {
    pub queue_url: String,
    pub max_messages: Option<i32>,
    pub wait_time_seconds: Option<i32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KinesisPutRecordRequest {
    pub stream_name: String,
    pub data: String,
    pub partition_key: String,
    pub sequence_number: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamoDBPutItemRequest {
    pub table_name: String,
    pub item: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamoDBGetItemRequest {
    pub table_name: String,
    pub key: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamoDBQueryRequest {
    pub table_name: String,
    pub key_condition_expression: String,
    pub expression_attribute_values: serde_json::Value,
    pub expression_attribute_names: Option<serde_json::Value>,
}

// CloudWatch metrics request/response types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloudWatchMetricsRequest {
    pub resource_id: String,
    pub resource_type: String,
    pub region: String,
    pub metrics: Vec<String>,
    pub period: i32,
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloudWatchMetricsResult {
    pub resource_id: String,
    pub resource_type: String,
    pub metrics: Vec<CloudWatchMetricData>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloudWatchMetricData {
    pub namespace: String,
    pub metric_name: String,
    pub unit: String,
    pub datapoints: Vec<CloudWatchDatapoint>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloudWatchDatapoint {
    pub timestamp: DateTime<Utc>,
    pub value: f64,
    pub unit: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloudWatchLogsRequest {
    pub log_group_name: String,
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
    pub filter_pattern: Option<String>,
    pub export_path: Option<String>,
    pub upload_to_s3: Option<bool>,
    pub s3_bucket: Option<String>,
    pub post_to_url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloudWatchLogsResult {
    pub log_group_name: String,
    pub events: Vec<CloudWatchLogEvent>,
    pub export_path: Option<String>,
    pub s3_url: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CloudWatchLogEvent {
    pub timestamp: DateTime<Utc>,
    pub message: String,
    pub event_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScheduleMetricsRequest {
    pub resource_id: String,
    pub resource_type: String,
    pub metrics: Vec<String>,
    pub period: i32,
    pub interval_seconds: u64,
    pub export_path: Option<String>,
    pub upload_to_s3: Option<bool>,
    pub s3_bucket: Option<String>,
    pub post_to_url: Option<String>,
}

impl AwsService {
    pub fn new(aws_resource_repo: Arc<AwsResourceRepository>, config: Config) -> Self {
        Self { aws_resource_repo, config }
    }

    // Get AWS configuration based on profile/region
    pub async fn get_aws_config(&self, profile: Option<&str>, region: &str) -> Result<AwsConfig, AppError> {
        let aws_configs = &self.config.cloud.aws;
        
        // Find the AWS config based on profile or default if not specified
        let aws_config = match profile {
            Some(profile_name) => {
                let config = aws_configs.iter()
                    .find(|c| c.profile.as_ref().map_or(false, |p| p == profile_name))
                    .cloned();
                
                if config.is_none() {
                    debug!("AWS profile not found in configuration: {:?}", profile_name);
                    // Check if the profile exists in the credentials file but isn't in our config
                    if let Ok(profiles) = Self::list_available_profiles() {
                        if profiles.contains(&profile_name.to_string()) {
                            debug!("Profile exists in credentials file but not in app config"); 
                        } else {
                            debug!("Profile does not exist in credentials file");
                        }
                    }
                }
                
                config
            },
            None => aws_configs.first().cloned(),
        }.ok_or_else(|| {
            AppError::Config(format!("AWS configuration not found for profile: {:?}", profile))
        })?;
        
        Ok(aws_config)
    }
    
    // Helper method to list available AWS profiles (for better error messages)
    fn list_available_profiles() -> Result<Vec<String>, std::io::Error> {
        let home = std::env::var("HOME").unwrap_or_else(|_| String::from("."));
        let credentials_path = format!("{}/.aws/credentials", home);
        
        if let Ok(content) = fs::read_to_string(credentials_path) {
            let mut profiles = Vec::new();
            for line in content.lines() {
                if line.starts_with('[') && line.ends_with(']') {
                    let profile = line.trim_start_matches('[').trim_end_matches(']').to_string();
                    if profile != "default" {
                        profiles.push(profile);
                    } else {
                        profiles.insert(0, profile); // Put default first
                    }
                }
            }
            Ok(profiles)
        } else {
            Ok(vec!["default".to_string()])
        }
    }

    // Load AWS SDK configuration for a given profile and region - backward compatible version
    pub async fn load_aws_sdk_config(&self, profile: Option<&str>, region: &str) -> Result<aws_config::SdkConfig, AppError> {
        self.load_aws_sdk_config_with_auth(profile, region, None).await
    }

    // Load AWS SDK configuration with authentication info
    pub async fn load_aws_sdk_config_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<aws_config::SdkConfig, AppError> {
        // Get the AWS config from our application's configuration
        let aws_config = match self.get_aws_config(profile, region).await {
            Ok(config) => config,
            Err(e) => {
                debug!("Could not find AWS configuration for profile: {:?}. Using account credentials if available.", profile);
                // Instead of failing immediately, create a default config that we can add credentials to
                AwsConfig {
                    name: "fallback".to_string(),
                    profile: profile.map(String::from),
                    region: region.to_string(),
                    access_key_id: account_auth.and_then(|auth| auth.access_key_id.clone()),
                    secret_access_key: account_auth.and_then(|auth| auth.secret_access_key.clone()),
                    role_arn: account_auth.and_then(|auth| auth.role_arn.clone()),
                }
            }
        };
        
        // Start building the AWS SDK config with the region
        let config_builder = aws_config::from_env()
            .region(aws_types::region::Region::new(region.to_string()));
        
        // Try different authentication methods in order of preference:
        // 1. If access keys are provided directly, use them
        // 2. If IAM role is specified, use role assumption
        // 3. If profile is specified, try to use it
        // 4. Fall back to default credential provider chain
        
        let config = if let (Some(access_key), Some(secret_key)) = (&aws_config.access_key_id, &aws_config.secret_access_key) {
            debug!("Using access key authentication");
            // Use API key authentication
            let credentials_provider = aws_sdk_s3::config::Credentials::new(
                access_key, 
                secret_key,
                None,
                None,
                "static-credentials"
            );
            config_builder.credentials_provider(credentials_provider).load().await
        } else if let Some(role_arn) = aws_config.role_arn {
            debug!("Using IAM role authentication with role: {}", role_arn);
            // Use assumed role
            // In a real implementation, would use STS to assume role with AWS SDK
            // For now, we'll just use default credential provider which should include role assumption
            config_builder.load().await
        } else if let Some(profile_name) = &aws_config.profile {
            debug!("Attempting to use AWS profile: {}", profile_name);
            // Try to use the named profile
            let provider = aws_config::profile::ProfileFileCredentialsProvider::builder()
                .profile_name(profile_name)
                .build();
            
            config_builder.credentials_provider(provider).load().await
        } else {
            debug!("No explicit authentication method configured, using default credential provider chain");
            // Use default credential provider chain (environment, instance profile, etc.)
            config_builder.load().await
        };
        
        Ok(config)
    }

    // Create EC2 client - backward compatible
    pub async fn create_ec2_client(&self, profile: Option<&str>, region: &str) -> Result<Ec2Client, AppError> {
        self.create_ec2_client_with_auth(profile, region, None).await
    }
    
    // Create EC2 client with authentication
    pub async fn create_ec2_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<Ec2Client, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(Ec2Client::new(&config))
    }
    
    pub async fn create_cloudwatch_client(&self, profile: Option<&str>, region: &str) -> Result<CloudWatchClient, AppError> {
        let config = self.get_aws_config(profile, region).await?;
        Ok(CloudWatchClient::new(&config))
    }
    
    pub async fn create_s3_client(&self, profile: Option<&str>, region: &str) -> Result<S3Client, AppError> {
        let config = self.get_aws_config(profile, region).await?;
        Ok(S3Client::new(&config))
    }

    pub async fn create_dynamodb_client(&self, profile: Option<&str>, region: &str) -> Result<DynamoDbClient, AppError> {
        let config = self.get_aws_config(profile, region).await?;
        Ok(DynamoDbClient::new(&config))
    }
    
    // Create RDS client - backward compatible
    pub async fn create_rds_client(&self, profile: Option<&str>, region: &str) -> Result<RdsClient, AppError> {
        self.create_rds_client_with_auth(profile, region, None).await
    }
    
    // Create RDS client with authentication
    pub async fn create_rds_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<RdsClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(RdsClient::new(&config))
    }
    
    // Create DynamoDB client - backward compatible
    pub async fn create_dynamodb_client(&self, profile: Option<&str>, region: &str) -> Result<DynamoDbClient, AppError> {
        self.create_dynamodb_client_with_auth(profile, region, None).await
    }
    
    // Create DynamoDB client with authentication
    pub async fn create_dynamodb_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<DynamoDbClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(DynamoDbClient::new(&config))
    }
    
    // Create Kinesis client - backward compatible
    pub async fn create_kinesis_client(&self, profile: Option<&str>, region: &str) -> Result<KinesisClient, AppError> {
        self.create_kinesis_client_with_auth(profile, region, None).await
    }
    
    // Create Kinesis client with authentication
    pub async fn create_kinesis_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<KinesisClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(KinesisClient::new(&config))
    }
    
    // Create SQS client - backward compatible
    pub async fn create_sqs_client(&self, profile: Option<&str>, region: &str) -> Result<SqsClient, AppError> {
        self.create_sqs_client_with_auth(profile, region, None).await
    }
    
    // Create SQS client with authentication
    pub async fn create_sqs_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<SqsClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(SqsClient::new(&config))
    }
    
    // Create SNS client - backward compatible
    pub async fn create_sns_client(&self, profile: Option<&str>, region: &str) -> Result<SnsClient, AppError> {
        self.create_sns_client_with_auth(profile, region, None).await
    }
    
    // Create SNS client with authentication
    pub async fn create_sns_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<SnsClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        let client = SnsClient::new(&config);
        Ok(client)
    }

    // Create CloudWatch client - backward compatible
    pub async fn create_cloudwatch_client(&self, profile: Option<&str>, region: &str) -> Result<CloudWatchClient, AppError> {
        self.create_cloudwatch_client_with_auth(profile, region, None).await
    }
    
    // Create CloudWatch client with authentication
    pub async fn create_cloudwatch_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<CloudWatchClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        let client = CloudWatchClient::new(&config);
        Ok(client)
    }
    
    pub async fn create_lambda_client(&self, profile: Option<&str>, region: &str) -> Result<LambdaClient, AppError> {
        self.create_lambda_client_with_auth(profile, region, None).await
    }
    
    pub async fn create_lambda_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<LambdaClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        let client = LambdaClient::new(&config);
        Ok(client)
    }
    
    pub async fn create_elasticache_client(&self, profile: Option<&str>, region: &str) -> Result<ElasticacheClient, AppError> {
        self.create_elasticache_client_with_auth(profile, region, None).await
    }
    
    pub async fn create_elasticache_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<ElasticacheClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        let client = ElasticacheClient::new(&config);
        Ok(client)
    }
    
    pub async fn create_opensearch_client(&self, profile: Option<&str>, region: &str) -> Result<OpenSearchClient, AppError> {
        self.create_opensearch_client_with_auth(profile, region, None).await
    }
    
    pub async fn create_opensearch_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<OpenSearchClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        let client = OpenSearchClient::new(&config);
        Ok(client)
    }
    
    // Create Cost Explorer client - backward compatible
    pub async fn create_cost_explorer_client(&self, profile: Option<&str>, region: &str) -> Result<CostExplorerClient, AppError> {
        self.create_cost_explorer_client_with_auth(profile, region, None).await
    }
    
    // Create Cost Explorer client with authentication
    pub async fn create_cost_explorer_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<CostExplorerClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(CostExplorerClient::new(&config))
    }
}

impl AwsControlPlane {
    pub fn new(aws_service: Arc<AwsService>) -> Self {
        Self { aws_service }
    }

    // Sync EC2 instances for an account and region - backward compatible version
    pub async fn sync_ec2_instances(&self, account_id: &str, profile: Option<&str>, region: &str) -> Result<Vec<AwsResourceModel>, AppError> {
        self.sync_ec2_instances_with_auth(account_id, profile, region, None).await
    }

    // Sync EC2 instances with authentication
    pub async fn sync_ec2_instances_with_auth(&self, account_id: &str, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<Vec<AwsResourceModel>, AppError> {
        let client = self.aws_service.create_ec2_client_with_auth(profile, region, account_auth).await?;
        self.sync_ec2_instances_with_client(account_id, profile, region, client).await
    }

    // Sync EC2 instances with provided client
    pub async fn sync_ec2_instances_with_client(&self, account_id: &str, profile: Option<&str>, region: &str, _client: Ec2Client) -> Result<Vec<AwsResourceModel>, AppError> {
        let mut instances = Vec::new();
        let instance = AwsResourceDto {
            id: None,
            account_id: account_id.to_string(),
            profile: profile.map(|p| p.to_string()),
            region: region.to_string(),
            resource_type: "EC2Instance".to_string(),
            resource_id: "i-0123456789abcdef0".to_string(),
            arn: format!("arn:aws:ec2:{}:{}:instance/i-0123456789abcdef0", region, account_id),
            name: Some("Sample EC2 Instance 1".to_string()),
            tags: json!({"Name": "Sample EC2 Instance 1", "Environment": "Development"}),
            resource_data: json!({
                "instance_id": "i-0123456789abcdef0",
                "instance_type": "t2.micro",
                "state": "running",
                "availability_zone": format!("{}a", region),
                "public_ip": "203.0.113.1",
                "private_ip": "10.0.0.1",
                "launch_time": "2023-05-01T12:00:00Z",
                "vpc_id": "vpc-0123abcd",
                "subnet_id": "subnet-0123abcd"
            }),
        };
        instances.push(instance);

        Ok(instances.into_iter().map(|i| i.into()).collect())
    }

    // Sync S3 buckets for an account - backward compatible version
    pub async fn sync_s3_buckets(&self, account_id: &str, profile: Option<&str>, region: &str) -> Result<Vec<AwsResourceModel>, AppError> {
        self.sync_s3_buckets_with_auth(account_id, profile, region, None).await
    }
    
    // Sync S3 buckets with authentication
    pub async fn sync_s3_buckets_with_auth(&self, account_id: &str, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<Vec<AwsResourceModel>, AppError> {
        let client = self.aws_service.create_s3_client_with_auth(profile, region, account_auth).await?;
        self.sync_s3_buckets_with_client(account_id, profile, region, client).await
    }
    
    // Sync S3 buckets with provided client
    pub async fn sync_s3_buckets_with_client(&self, account_id: &str, profile: Option<&str>, region: &str, _client: S3Client) -> Result<Vec<AwsResourceModel>, AppError> {
        let mut buckets = Vec::new();
        let bucket = AwsResourceDto {
            id: None,
            account_id: account_id.to_string(),
            profile: profile.map(|p| p.to_string()),
            region: region.to_string(),
            resource_type: "S3Bucket".to_string(),
            resource_id: "example-bucket-1".to_string(),
            arn: format!("arn:aws:s3:::example-bucket-1"),
            name: Some("example-bucket-1".to_string()),
            tags: json!({"Purpose": "Logs", "Environment": "Development"}),
            resource_data: json!({
                "creation_date": "2023-01-15T10:00:00Z",
                "region": region
            }),
        };
        buckets.push(bucket);

        Ok(buckets.into_iter().map(|b| b.into()).collect())
    }

    // Sync RDS instances - backward compatible version
    pub async fn sync_rds_instances(&self, account_id: &str, profile: Option<&str>, region: &str) -> Result<Vec<AwsResourceModel>, AppError> {
        self.sync_rds_instances_with_auth(account_id, profile, region, None).await
    }
    
    // Sync RDS instances with authentication
    pub async fn sync_rds_instances_with_auth(&self, account_id: &str, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<Vec<AwsResourceModel>, AppError> {
        let client = self.aws_service.create_rds_client_with_auth(profile, region, account_auth).await?;
        self.sync_rds_instances_with_client(account_id, profile, region, client).await
    }
    
    // Sync RDS instances with provided client
    pub async fn sync_rds_instances_with_client(&self, account_id: &str, profile: Option<&str>, region: &str, _client: RdsClient) -> Result<Vec<AwsResourceModel>, AppError> {
        // Implementation using the provided client
        Ok(Vec::new())
    }

    // Sync DynamoDB tables - backward compatible version
    pub async fn sync_dynamodb_tables(&self, account_id: &str, profile: Option<&str>, region: &str) -> Result<Vec<AwsResourceModel>, AppError> {
        self.sync_dynamodb_tables_with_auth(account_id, profile, region, None).await
    }
    
    // Sync DynamoDB tables with authentication
    pub async fn sync_dynamodb_tables_with_auth(&self, account_id: &str, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<Vec<AwsResourceModel>, AppError> {
        let client = self.aws_service.create_dynamodb_client_with_auth(profile, region, account_auth).await?;
        self.sync_dynamodb_tables_with_client(account_id, profile, region, client).await
    }
    
    // Sync DynamoDB tables with provided client
    pub async fn sync_dynamodb_tables_with_client(&self, account_id: &str, profile: Option<&str>, region: &str, _client: DynamoDbClient) -> Result<Vec<AwsResourceModel>, AppError> {
        let mut tables = Vec::new();
        let table = AwsResourceDto {
            id: None,
            account_id: account_id.to_string(),
            profile: profile.map(|p| p.to_string()),
            region: region.to_string(),
            resource_type: "DynamoDbTable".to_string(),
            resource_id: "sample-users".to_string(),
            arn: format!("arn:aws:dynamodb:{}:{}:table/sample-users", region, account_id),
            name: Some("Sample Users Table".to_string()),
            tags: json!({"Name": "Users Table", "Environment": "Development"}),
            resource_data: json!({
                "table_name": "sample-users",
                "status": "ACTIVE",
                "creation_date": "2023-03-15T08:45:00Z",
                "provisioned_throughput": {
                    "read_capacity_units": 5,
                    "write_capacity_units": 5
                },
                "key_schema": [
                    {
                        "attribute_name": "user_id",
                        "key_type": "HASH"
                    }
                ],
                "attribute_definitions": [
                    {
                        "attribute_name": "user_id",
                        "attribute_type": "S"
                    }
                ],
                "item_count": 42,
                "table_size_bytes": 12345
            }),
        };
        tables.push(table);

        Ok(tables.into_iter().map(|t| t.into()).collect())
    }

    // Sync Kinesis streams - backward compatible version
    pub async fn sync_kinesis_streams(&self, account_id: &str, profile: Option<&str>, region: &str) -> Result<Vec<AwsResourceModel>, AppError> {
        self.sync_kinesis_streams_with_auth(account_id, profile, region, None).await
    }
    
    // Sync Kinesis streams with authentication
    pub async fn sync_kinesis_streams_with_auth(&self, account_id: &str, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<Vec<AwsResourceModel>, AppError> {
        let client = self.aws_service.create_kinesis_client_with_auth(profile, region, account_auth).await?;
        self.sync_kinesis_streams_with_client(account_id, profile, region, client).await
    }
    
    // Sync Kinesis streams with provided client
    pub async fn sync_kinesis_streams_with_client(&self, account_id: &str, profile: Option<&str>, region: &str, _client: KinesisClient) -> Result<Vec<AwsResourceModel>, AppError> {
        // Implementation using the provided client
        Ok(Vec::new())
    }
    
    // Sync SQS queues - backward compatible version
    pub async fn sync_sqs_queues(&self, account_id: &str, profile: Option<&str>, region: &str) -> Result<Vec<AwsResourceModel>, AppError> {
        self.sync_sqs_queues_with_auth(account_id, profile, region, None).await
    }
    
    // Sync SQS queues with authentication
    pub async fn sync_sqs_queues_with_auth(&self, account_id: &str, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<Vec<AwsResourceModel>, AppError> {
        let client = self.aws_service.create_sqs_client_with_auth(profile, region, account_auth).await?;
        self.sync_sqs_queues_with_client(account_id, profile, region, client).await
    }
    
    // Sync SQS queues with provided client
    pub async fn sync_sqs_queues_with_client(&self, account_id: &str, profile: Option<&str>, region: &str, client: SqsClient) -> Result<Vec<AwsResourceModel>, AppError> {
        let repo = &self.aws_service.aws_resource_repo;
        
        // In a real implementation, this would call list_queues and get_queue_attributes
        
        let mut queues = Vec::new();
        
        // Sample standard queue
        let standard_queue_data = json!({
            "queue_url": format!("https://sqs.{}.amazonaws.com/{}/sample-standard-queue", region, account_id),
            "queue_type": "Standard",
            "visibility_timeout": 30,
            "message_retention_period": 345600,
            "delay_seconds": 0,
            "receive_message_wait_time_seconds": 0,
            "created_timestamp": "2023-04-15T14:30:00Z"
        });
        
        let standard_queue = AwsResourceDto {
            id: None,
            account_id: account_id.to_string(),
            profile: profile.map(|p| p.to_string()),
            region: region.to_string(),
            resource_type: AwsResourceType::SqsQueue.to_string(),
            resource_id: "sample-standard-queue".to_string(),
            arn: format!("arn:aws:sqs:{}:{}:sample-standard-queue", region, account_id),
            name: Some("Sample Standard Queue".to_string()),
            tags: json!({"Name": "Sample Standard Queue", "Environment": "Development"}),
            resource_data: standard_queue_data,
        };
        
        // Sample FIFO queue
        let fifo_queue_data = json!({
            "queue_url": format!("https://sqs.{}.amazonaws.com/{}/sample-fifo-queue.fifo", region, account_id),
            "queue_type": "FIFO",
            "visibility_timeout": 60,
            "message_retention_period": 86400,
            "delay_seconds": 0,
            "receive_message_wait_time_seconds": 20,
            "fifo_queue": true,
            "content_based_deduplication": true,
            "created_timestamp": "2023-04-15T15:45:00Z"
        });
        
        let fifo_queue = AwsResourceDto {
            id: None,
            account_id: account_id.to_string(),
            profile: profile.map(|p| p.to_string()),
            region: region.to_string(),
            resource_type: AwsResourceType::SqsQueue.to_string(),
            resource_id: "sample-fifo-queue.fifo".to_string(),
            arn: format!("arn:aws:sqs:{}:{}:sample-fifo-queue.fifo", region, account_id),
            name: Some("Sample FIFO Queue".to_string()),
            tags: json!({"Name": "Sample FIFO Queue", "Environment": "Production", "DeduplicationMethod": "ContentBased"}),
            resource_data: fifo_queue_data,
        };
        
        // Save to database
        let saved_standard_queue = match repo.find_by_arn(&standard_queue.arn).await? {
            Some(existing) => repo.update(existing.id, &standard_queue).await?,
            None => repo.create(&standard_queue).await?,
        };
        queues.push(saved_standard_queue);
        
        let saved_fifo_queue = match repo.find_by_arn(&fifo_queue.arn).await? {
            Some(existing) => repo.update(existing.id, &fifo_queue).await?,
            None => repo.create(&fifo_queue).await?,
        };
        queues.push(saved_fifo_queue);
        
        Ok(queues)
    }

    // Sync all resources for an account and region
    pub async fn sync_resources(&self, request: &ResourceSyncRequest) -> Result<ResourceSyncResponse, AppError> {
        let account_id = &request.account_id;
        let profile = request.profile.as_deref();
        let region = &request.region;
        
        // Create account auth info from request for authentication fallback
        let account_auth = AccountAuthInfo::from(request);
        
        // Get resource types to sync
        let resource_types = match &request.resource_types {
            Some(types) => types.clone(),
            None => vec![
                AwsResourceType::EC2Instance.to_string(),
                AwsResourceType::S3Bucket.to_string(),
                AwsResourceType::RdsInstance.to_string(),
                AwsResourceType::DynamoDbTable.to_string(),
                AwsResourceType::KinesisStream.to_string(),
                AwsResourceType::SqsQueue.to_string(),
                AwsResourceType::ElasticacheCluster.to_string(),
            ],
        };
        
        let mut summary = Vec::new();
        let mut total_resources = 0;
        
        for resource_type in resource_types {
            let result = match resource_type.as_str() {
                "EC2Instance" => {
                    let instances = self.sync_ec2_instances_with_auth(account_id, profile, region, Some(&account_auth)).await?;
                    summary.push(ResourceTypeSyncSummary {
                        resource_type: AwsResourceType::EC2Instance.to_string(),
                        count: instances.len(),
                        status: "success".to_string(),
                        details: None,
                    });
                    total_resources += instances.len();
                    Ok(()) as Result<(), AppError>
                },
                "S3Bucket" => {
                    let buckets = self.sync_s3_buckets_with_auth(account_id, profile, region, Some(&account_auth)).await?;
                    summary.push(ResourceTypeSyncSummary {
                        resource_type: AwsResourceType::S3Bucket.as_str().to_string(),
                        count: buckets.len(),
                        status: "success".to_string(),
                        details: None,
                    });
                    total_resources += buckets.len();
                    Ok(()) as Result<(), AppError>
                },
                "RdsInstance" => {
                    let instances = self.sync_rds_instances_with_auth(account_id, profile, region, Some(&account_auth)).await?;
                    summary.push(ResourceTypeSyncSummary {
                        resource_type: AwsResourceType::RdsInstance.as_str().to_string(),
                        count: instances.len(),
                        status: "success".to_string(),
                        details: None,
                    });
                    total_resources += instances.len();
                    Ok(()) as Result<(), AppError>
                },
                "DynamoDbTable" => {
                    let tables = self.sync_dynamodb_tables_with_auth(account_id, profile, region, Some(&account_auth)).await?;
                    summary.push(ResourceTypeSyncSummary {
                        resource_type: AwsResourceType::DynamoDbTable.as_str().to_string(),
                        count: tables.len(),
                        status: "success".to_string(),
                        details: None,
                    });
                    total_resources += tables.len();
                    Ok(()) as Result<(), AppError>
                },
                "KinesisStream" => {
                    let streams = self.sync_kinesis_streams_with_auth(account_id, profile, region, Some(&account_auth)).await?;
                    summary.push(ResourceTypeSyncSummary {
                        resource_type: AwsResourceType::KinesisStream.to_string(),
                        count: streams.len(),
                        status: "success".to_string(),
                        details: None,
                    });
                    total_resources += streams.len();
                    Ok(()) as Result<(), AppError>
                },
                "SqsQueue" => {
                    let queues = self.sync_sqs_queues_with_auth(account_id, profile, region, Some(&account_auth)).await?;
                    summary.push(ResourceTypeSyncSummary {
                        resource_type: AwsResourceType::SqsQueue.as_str().to_string(),
                        count: queues.len(),
                        status: "success".to_string(),
                        details: None,
                    });
                    total_resources += queues.len();
                    Ok(()) as Result<(), AppError>
                },
                "ElasticacheCluster" => {
                    // Create a CloudWatchService and use it to sync ElastiCache clusters
                    let cloudwatch_client = self.aws_service.create_cloudwatch_client_with_auth(profile, region, Some(&account_auth)).await?;
                    let cloudwatch_service = CloudWatchService::new(self.aws_service.clone(), cloudwatch_client);
                    let clusters = cloudwatch_service.sync_elasticache_clusters_with_auth(account_id, profile, region, Some(&account_auth)).await?;
                    summary.push(ResourceTypeSyncSummary {
                        resource_type: AwsResourceType::ElasticacheCluster.to_string(),
                        count: clusters.len(),
                        status: "success".to_string(),
                        details: None,
                    });
                    total_resources += clusters.len();
                    Ok(()) as Result<(), AppError>
                },
                _ => {
                    summary.push(ResourceTypeSyncSummary {
                        resource_type: resource_type.clone(),
                        count: 0,
                        status: "skipped".to_string(),
                        details: Some("Resource type not supported".to_string()),
                    });
                    Ok(()) as Result<(), AppError>
                },
            };
            
            if let Err(e) = result {
                summary.push(ResourceTypeSyncSummary {
                    resource_type: resource_type.clone(),
                    count: 0,
                    status: "error".to_string(),
                    details: Some(e.to_string()),
                });
            }
        }
        
        Ok(ResourceSyncResponse {
            summary,
            total_resources,
            sync_time: Utc::now().to_rfc3339(),
        })
    }
}

impl AwsDataPlane {
    pub fn new(aws_service: Arc<AwsService>) -> Self {
        Self { aws_service }
    }
    
    // S3 data plane operations
    pub async fn s3_get_object(&self, profile: Option<&str>, region: &str, request: &S3GetObjectRequest) -> Result<serde_json::Value, AppError> {
        let client = self.aws_service.create_s3_client(profile, region).await?;
        
        // In a real implementation, this would call get_object
        // For now, provide mock data
        
        info!("Getting object {} from bucket {}", request.key, request.bucket);
        
        let response = json!({
            "body": "This is sample content for the S3 object",
            "content_type": "text/plain",
            "content_length": 38,
            "last_modified": Utc::now().to_rfc3339(),
            "etag": "\"abcdef1234567890\"",
            "metadata": {
                "custom-key": "custom-value"
            }
        });
        
        Ok(response)
    }
    
    pub async fn s3_put_object(&self, profile: Option<&str>, region: &str, request: &S3PutObjectRequest) -> Result<serde_json::Value, AppError> {
        let client = self.aws_service.create_s3_client(profile, region).await?;
        
        // In a real implementation, this would call put_object
        
        info!("Putting object {} in bucket {}", request.key, request.bucket);
        
        let response = json!({
            "etag": "\"abcdef1234567890\"",
            "version_id": null,
            "content_length": request.body.len(),
            "content_type": request.content_type.clone().unwrap_or_else(|| "application/octet-stream".to_string())
        });
        
        Ok(response)
    }
    
    // DynamoDB data plane operations
    pub async fn dynamodb_get_item(&self, profile: Option<&str>, region: &str, request: &DynamoDBGetItemRequest) -> Result<serde_json::Value, AppError> {
        let client = self.aws_service.create_dynamodb_client(profile, region).await?;
        
        // In a real implementation, this would call get_item
        
        info!("Getting item from table {}", request.table_name);
        
        // Sample response
        let response = json!({
            "item": {
                "user_id": {"S": "12345"},
                "username": {"S": "johndoe"},
                "email": {"S": "john@example.com"},
                "created_at": {"S": "2023-01-15T10:30:00Z"},
                "active": {"BOOL": true}
            }
        });
        
        Ok(response)
    }
    
    pub async fn dynamodb_put_item(&self, profile: Option<&str>, region: &str, request: &DynamoDBPutItemRequest) -> Result<serde_json::Value, AppError> {
        let client = self.aws_service.create_dynamodb_client(profile, region).await?;
        
        // In a real implementation, this would call put_item
        
        info!("Putting item into table {}", request.table_name);
        
        // Sample response
        let response = json!({
            "consumed_capacity": {
                "capacity_units": 1.0,
                "table_name": request.table_name
            }
        });
        
        Ok(response)
    }
    
    pub async fn dynamodb_query(&self, profile: Option<&str>, region: &str, request: &DynamoDBQueryRequest) -> Result<serde_json::Value, AppError> {
        let client = self.aws_service.create_dynamodb_client(profile, region).await?;
        
        // In a real implementation, this would call query
        
        info!("Querying table {}", request.table_name);
        
        // Sample response with mock data
        let response = json!({
            "items": [
                { "id": "item1", "name": "First Item", "value": 100 },
                { "id": "item2", "name": "Second Item", "value": 200 },
                { "id": "item3", "name": "Third Item", "value": 300 }
            ],
            "count": 3,
            "scanned_count": 5,
            "last_evaluated_key": null
        });
        
        Ok(response)
    }
    
    // CloudWatch Metrics operations
    pub async fn get_cloudwatch_metrics(&self, request: &CloudWatchMetricsRequest) -> Result<CloudWatchMetricsResult, AppError> {
        let namespace = match request.resource_type.as_str() {
            "EC2Instance" => "AWS/EC2",
            "RdsInstance" => "AWS/RDS",
            "DynamoDbTable" => "AWS/DynamoDB",
            "KinesisStream" => "AWS/Kinesis",
            "SqsQueue" => "AWS/SQS",
            "ElasticacheCluster" => "AWS/ElastiCache",
            "SnsTopic" => "AWS/SNS",
            "LambdaFunction" => "AWS/Lambda",
            "OpenSearchDomain" => "AWS/ES",
            _ => return Err(AppError::BadRequest("Unsupported resource type".to_string())),
        };

        // Build dimension values for resource filtering
        let dimension_values = aws_sdk_costexplorer::types::DimensionValues::builder()
            .key(aws_sdk_costexplorer::types::Dimension::ResourceId)
            .values(vec![resource_id.to_string()])
            .build()
            .map_err(|e| AppError::External(format!("Failed to build dimension values: {}", e)))?;

        // Build the filter expression
        let filter = aws_sdk_costexplorer::types::Expression::builder()
            .dimensions(dimension_values)
            .build()
            .map_err(|e| AppError::External(format!("Failed to build filter: {}", e)))?;

        let request = aws_sdk_costexplorer::operation::get_cost_and_usage::GetCostAndUsageInput::builder()
            .time_period(time_period)
            .granularity(aws_sdk_costexplorer::types::Granularity::Daily)
            .filter(filter)
            .metrics(["UnblendedCost"].iter().map(|s| s.to_string()).collect::<Vec<_>>())
            .build()
            .map_err(|e| AppError::External(format!("Failed to build cost explorer request: {}", e)))?;
    }
}

// Implement the AwsClientFactory trait for AwsService
#[async_trait]
impl AwsClientFactory for AwsService {
    async fn get_aws_config(&self, profile: Option<&str>, region: &str) -> Result<AwsConfig, AppError> {
        let aws_configs = &self.config.cloud.aws;
        
        match profile {
            Some(profile_name) => {
                let config = aws_configs.iter()
                    .find(|c| c.profile.as_ref().map_or(false, |p| p == profile_name))
                    .cloned();
                
                if config.is_none() {
                    debug!("AWS profile not found in configuration: {:?}", profile_name);
                    // Check if the profile exists in the credentials file
                    if let Ok(profiles) = Self::list_available_profiles() {
                        if profiles.contains(&profile_name.to_string()) {
                            debug!("Profile exists in credentials file but not in app config"); 
                        } else {
                            debug!("Profile does not exist in credentials file");
                        }
                    }
                }
                
                config.ok_or_else(|| {
                    AppError::Config(format!("AWS configuration not found for profile: {:?}", profile))
                })
            }
            None => aws_configs.first().cloned().ok_or_else(|| {
                AppError::Config("No default AWS configuration found".to_string())
            })
        }
    }

    async fn get_aws_config_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<AwsConfig, AppError> {
        match self.get_aws_config(profile, region).await {
            Ok(config) => Ok(config),
            Err(_) => {
                // Create a default config with provided auth info
                Ok(AwsConfig {
                    name: "fallback".to_string(),
                    profile: profile.map(String::from),
                    region: region.to_string(),
                    access_key_id: account_auth.and_then(|auth| auth.access_key_id.clone()),
                    secret_access_key: account_auth.and_then(|auth| auth.secret_access_key.clone()),
                    role_arn: account_auth.and_then(|auth| auth.role_arn.clone()),
                })
            }
        }
    }

    // AWS Service Client Creation Methods
    async fn create_cloudwatch_client(&self, profile: Option<&str>, region: &str) -> Result<CloudWatchClient, AppError> {
        self.create_cloudwatch_client_with_auth(profile, region, None).await
    }

    async fn create_cloudwatch_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<CloudWatchClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(CloudWatchClient::new(&config))
    }

    async fn create_cost_explorer_client(&self, profile: Option<&str>, region: &str) -> Result<CostExplorerClient, AppError> {
        self.create_cost_explorer_client_with_auth(profile, region, None).await
    }

    async fn create_cost_explorer_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<CostExplorerClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(CostExplorerClient::new(&config))
    }

    async fn create_ec2_client(&self, profile: Option<&str>, region: &str) -> Result<Ec2Client, AppError> {
        self.create_ec2_client_with_auth(profile, region, None).await
    }

    async fn create_ec2_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<Ec2Client, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(Ec2Client::new(&config))
    }

    async fn create_s3_client(&self, profile: Option<&str>, region: &str) -> Result<S3Client, AppError> {
        self.create_s3_client_with_auth(profile, region, None).await
    }

    async fn create_s3_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<S3Client, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(S3Client::new(&config))
    }

    async fn create_rds_client(&self, profile: Option<&str>, region: &str) -> Result<RdsClient, AppError> {
        self.create_rds_client_with_auth(profile, region, None).await
    }

    async fn create_rds_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<RdsClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(RdsClient::new(&config))
    }

    async fn create_dynamodb_client(&self, profile: Option<&str>, region: &str) -> Result<DynamoDbClient, AppError> {
        self.create_dynamodb_client_with_auth(profile, region, None).await
    }

    async fn create_dynamodb_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<DynamoDbClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(DynamoDbClient::new(&config))
    }

    async fn create_kinesis_client(&self, profile: Option<&str>, region: &str) -> Result<KinesisClient, AppError> {
        self.create_kinesis_client_with_auth(profile, region, None).await
    }

    async fn create_kinesis_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<KinesisClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(KinesisClient::new(&config))
    }

    async fn create_sqs_client(&self, profile: Option<&str>, region: &str) -> Result<SqsClient, AppError> {
        self.create_sqs_client_with_auth(profile, region, None).await
    }

    async fn create_sqs_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<SqsClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(SqsClient::new(&config))
    }

    async fn create_sns_client(&self, profile: Option<&str>, region: &str) -> Result<SnsClient, AppError> {
        self.create_sns_client_with_auth(profile, region, None).await
    }

    async fn create_sns_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<SnsClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(SnsClient::new(&config))
    }

    async fn create_lambda_client(&self, profile: Option<&str>, region: &str) -> Result<LambdaClient, AppError> {
        self.create_lambda_client_with_auth(profile, region, None).await
    }

    async fn create_lambda_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<LambdaClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(LambdaClient::new(&config))
    }

    async fn create_elasticache_client(&self, profile: Option<&str>, region: &str) -> Result<ElasticacheClient, AppError> {
        self.create_elasticache_client_with_auth(profile, region, None).await
    }

    async fn create_elasticache_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<ElasticacheClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(ElasticacheClient::new(&config))
    }

    async fn create_opensearch_client(&self, profile: Option<&str>, region: &str) -> Result<OpenSearchClient, AppError> {
        self.create_opensearch_client_with_auth(profile, region, None).await
    }

    async fn create_opensearch_client_with_auth(&self, profile: Option<&str>, region: &str, account_auth: Option<&AccountAuthInfo>) -> Result<OpenSearchClient, AppError> {
        let config = self.load_aws_sdk_config_with_auth(profile, region, account_auth).await?;
        Ok(OpenSearchClient::new(&config))
    }

    async fn create_client_with_auth<C>(&self, profile: Option<&str>, region: &str) -> Result<C, AppError> 
    where 
        C: From<AwsConfig>
    {
        let config = self.get_aws_config(profile, region).await?;
        Ok(C::from(config))
    }
}

impl AwsCostService {
    pub fn new(aws_service: Arc<AwsService>) -> Self {
        // Initialize with a default US East 1 region for Cost Explorer
        let shared_config = aws_config::from_env().region("us-east-1").load().sync();
        let cost_explorer_client = CostExplorerClient::new(&shared_config);
        
        AwsCostService {
            aws_service,
            cost_explorer_client,
        }
    }
}

impl CloudWatchService {
    pub fn new(aws_service: Arc<AwsService>) -> Self {
        // Initialize with a default US East 1 region for CloudWatch
        let shared_config = aws_config::from_env().region("us-east-1").load().sync();
        let cloudwatch_client = CloudWatchClient::new(&shared_config);
        
        CloudWatchService {
            aws_service,
            cloudwatch_client,
        }
    }

    pub async fn get_metrics(&self, profile: Option<&str>, region: &str, request: &CloudWatchMetricsRequest) -> Result<CloudWatchMetricsResult, AppError> {
        // Get a CloudWatch client for the specified region
        let client = self.aws_service.create_cloudwatch_client(profile, region).await?;

        let namespace = match request.resource_type.as_str() {
            "EC2Instance" => "AWS/EC2",
            "RdsInstance" => "AWS/RDS", 
            "DynamoDbTable" => "AWS/DynamoDB",
            "ElasticacheCluster" => "AWS/ElastiCache",
            _ => return Err(AppError::BadRequest(format!("Unsupported resource type: {}", request.resource_type))),
        };

        let mut metrics_data = Vec::new();
        for metric_name in &request.metrics {
            // Create dimensions based on resource type
            let dimensions = match request.resource_type.as_str() {
                "EC2Instance" => vec![
                    Dimension::builder()
                        .name("InstanceId")
                        .value(&request.resource_id)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                ],
                "RdsInstance" => vec![
                    Dimension::builder()
                        .name("DBInstanceIdentifier")
                        .value(&request.resource_id)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                ],
                "DynamoDbTable" => vec![
                    Dimension::builder()
                        .name("TableName")
                        .value(&request.resource_id)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                ],
                "ElasticacheCluster" => vec![
                    Dimension::builder()
                        .name("CacheClusterId")
                        .value(&request.resource_id)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                ],
                _ => vec![],
            };

            let metric_stat = MetricStat::builder()
                .metric(
                    Metric::builder()
                        .namespace(namespace)
                        .metric_name(metric_name)
                        .dimensions(dimensions)
                        .build()
                        .map_err(|e| AppError::External(e.to_string()))?
                )
                .period(request.period)
                .stat("Average")
                .build()
                .map_err(|e| AppError::External(e.to_string()))?;

            let metric_query = MetricDataQuery::builder()
                .metric_stat(metric_stat)
                .id(format!("m{}", metrics_data.len()))
                .build()
                .map_err(|e| AppError::External(e.to_string()))?;

            let get_metric_data_input = aws_sdk_cloudwatch::operation::get_metric_data::GetMetricDataInput::builder()
                .start_time(request.start_time)
                .end_time(request.end_time)
                .metric_data_queries(vec![metric_query])
                .build()
                .map_err(|e| AppError::External(e.to_string()))?;

            let metric_result = client.get_metric_data(get_metric_data_input).await
                .map_err(|e| AppError::External(e.to_string()))?;

            let mut datapoints = Vec::new();
            if let Some(results) = metric_result.metric_data_results() {
                for result in results {
                    if let (Some(timestamps), Some(values)) = (result.timestamps(), result.values()) {
                        for (ts, val) in timestamps.iter().zip(values.iter()) {
                            datapoints.push(CloudWatchDatapoint {
                                timestamp: *ts,
                                value: *val,
                                unit: "Count".to_string(), // Default unit, should be made dynamic
                            });
                        }
                    }
                }
            }

            metrics_data.push(CloudWatchMetricData {
                namespace: namespace.to_string(),
                metric_name: metric_name.clone(),
                unit: "Count".to_string(), // Default unit, should be made dynamic
                datapoints,
            });
        }

        Ok(CloudWatchMetricsResult {
            resource_id: request.resource_id.clone(),
            resource_type: request.resource_type.clone(),
            metrics: metrics_data,
        })
    }
}